<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Math Blaster - Core Edition</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #0a0a2e, #16213e, #1a1a3a);
            overflow: hidden;
            font-family: 'Inter', 'Arial', sans-serif;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            position: relative; 
        }
        
        canvas {
            display: block;
            background: radial-gradient(circle at 20% 80%, #120458 0%, transparent 50%),
                        radial-gradient(circle at 80% 20%, #2c1810 0%, transparent 50%),
                        radial-gradient(circle at 40% 40%, #0a0a2e 0%, transparent 50%);
            width: 100%;
            height: 100%;
        }
        
        .game-ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to pass through to canvas unless on a button */
            display: none; 
            flex-direction: column;
            align-items: center;
        }

        /* Pause Button Styling */
        .pause-button {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: clamp(24px, 4vw, 30px); /* Responsive font size */
            background-color: rgba(0, 120, 150, 0.7);
            color: #00ffff;
            border: 2px solid #00ffff;
            border-radius: 8px;
            padding: 5px 12px; /* Adjusted padding for hamburger icon */
            cursor: pointer;
            pointer-events: all; /* Make sure this button is clickable */
            z-index: 15; /* Ensure it's above other game UI but can be covered by menus */
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            transition: background-color 0.2s, transform 0.1s;
        }

        .pause-button:hover {
            background-color: rgba(0, 150, 180, 0.9);
            transform: scale(1.1);
        }
        
        .problem {
            margin-top: 30px;
            font-size: clamp(24px, 5vw, 36px);
            font-weight: bold;
            text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
            color: #00ffff;
            text-align: center;
        }
        
        .score-container { /* Container for score and shields */
            position: absolute;
            top: 20px;
            right: 30px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }
        .score {
            font-size: clamp(18px, 4vw, 24px);
            color: #ffff00;
            text-shadow: 0 0 5px #ffff00;
        }
        .shields-display {
            font-size: clamp(14px, 3vw, 18px);
            color: #00ff00; /* Green for shields */
            text-shadow: 0 0 3px #00ff00;
            margin-top: 5px;
        }
        
        .instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: clamp(12px, 2.5vw, 14px);
            color: #aaa;
            width: 90%;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 46, 0.97); 
            display: none; 
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 10; /* Ensure screens are above game canvas and general game UI */
            padding: 20px;
            box-sizing: border-box;
        }
        .screen h1 {
            font-size: clamp(30px, 7vw, 52px);
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
            margin-bottom: 30px;
        }
        .screen h2 { /* General title for screens like Level Complete, Game Over */
            font-size: clamp(26px, 6vw, 44px);
            color: #ffff00;
            text-shadow: 0 0 8px #ffff00;
            margin-bottom: 15px; /* Adjusted margin */
        }
        .screen button {
            background-color: #0077cc; 
            color: white;
            border: 2px solid #00ffff; 
            padding: 12px 25px;
            font-size: clamp(16px, 3.5vw, 22px);
            font-weight: bold;
            border-radius: 10px; 
            cursor: pointer;
            margin: 10px;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(0, 200, 255, 0.3); 
            min-width: 180px;
            pointer-events: all; /* Ensure buttons on screens are clickable */
        }
        .screen button:hover {
            background-color: #0099e6; 
            transform: translateY(-2px) scale(1.03); 
            box-shadow: 0 6px 20px rgba(0, 255, 255, 0.5);
        }
        /* General paragraph styling within screens, like score before it's moved */
        .screen > p { 
            font-size: clamp(16px, 3vw, 20px);
            margin-bottom: 20px;
        }


        .level-category-title {
            font-size: clamp(18px, 4vw, 24px);
            color: #ff8c00; /* Orange for category titles */
            margin-top: 20px;
            margin-bottom: 10px;
            text-shadow: 0 0 5px #ff8c00;
        }

        #levelSelectMenu .level-buttons-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 12px;
            max-width: 800px; /* Increased width for more buttons */
            margin-bottom: 15px;
        }
        #levelSelectMenu .level-buttons-container button {
            padding: 10px 15px;
            min-width: 55px; 
            font-size: clamp(14px, 3vw, 18px);
        }
         #levelSelectMenu .core-level-button { /* Specific style for core buttons if needed */
            min-width: 200px !important; /* Ensure core buttons are wider */
            padding: 12px 20px !important;
            font-size: clamp(15px, 3.2vw, 20px) !important;
        }

        /* Report Container Styling */
        .report-container {
            background-color: rgba(0, 0, 0, 0.4);
            padding: 15px; /* Padding around the entire container */
            border-radius: 8px;
            margin-top: 10px; /* Reduced margin from screen title */
            margin-bottom: 15px; 
            max-width: 90%;
            width: 600px; 
            min-height: 150px; /* Adjusted min-height */
            max-height: 350px; /* Adjusted max-height */
            border: 1px solid #00ffff66; 
            color: #e0e0e0; 
            text-align: left;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
            display: flex; /* Added for flex layout */
            flex-direction: column; /* Stack header and content vertically */
        }
        .report-container h3 { /* Header within the report */
            color: #ffff00;
            margin-top: 0; /* Remove default margin */
            margin-bottom: 10px;
            font-size: clamp(17px, 3.2vw, 20px); /* Adjusted font size */
            border-bottom: 1px solid #00ffff44;
            padding-bottom: 8px; /* Increased padding */
            flex-shrink: 0; /* Prevent header from shrinking */
        }
        .report-content-scrollable { /* New class for the scrollable area */
            flex-grow: 1; /* Allow this area to grow */
            overflow-y: auto; /* Enable vertical scrolling */
            padding-right: 10px; /* For scrollbar spacing if needed */
        }
         .report-container p { /* Paragraphs within the report (score, details) */
            margin-bottom: 10px; /* Adjusted margin */
            line-height: 1.6; /* Adjusted line height */
            font-size: clamp(15px, 2.8vw, 18px); /* Adjusted font size */
        }
        .report-container p.final-score-report { /* Specific class for the score line if needed */
             font-weight: bold;
             color: #00ff00; /* Make score stand out */
        }


        /* Initially hide all menu/info screens */
        #mainMenu, 
        #levelSelectMenu, 
        #levelCompleteScreen, 
        #gameOverScreen,
        #pauseMenuScreen { 
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div class="game-ui-container" id="gameUiContainer">
        <button id="pauseGameBtn" class="pause-button">☰</button>
        <div class="problem" id="problem">? × ? = ?</div>
        <div class="score-container">
            <div class="score" id="score">Score: 0</div>
            <div classs="shields-display" id="shieldsDisplay"></div>
        </div>
        <div class="instructions">
            Move: ←→ keys or mouse | Shoot: SPACEBAR or click/tap
        </div>
    </div>

    <div id="mainMenu" class="screen">
        <h1>Space Math Blaster</h1>
        <button id="selectLevelBtn">Select Level</button>
        <button id="settingsBtn">Settings</button>
    </div>

    <div id="levelSelectMenu" class="screen">
        <h2>Select Your Challenge</h2>
        <div class="level-category-title">Practice Levels (Times Tables)</div>
        <div class="level-buttons-container" id="practiceLevelsContainer"></div>
        <div class="level-category-title">Core Gameplay</div>
        <div class="level-buttons-container" id="coreLevelsContainer"></div>
        <button id="backToMainMenuBtnLvl">Back to Main Menu</button>
    </div>

    <div id="pauseMenuScreen" class="screen">
        <h2>Paused</h2>
        <button id="resumeGameBtn">Resume Game</button>
        <button id="pauseMenuSettingsBtn">Settings</button>
        <button id="exitToMainMenuBtn">Exit to Main Menu</button>
    </div>

    <div id="levelCompleteScreen" class="screen">
        <h2>Level Complete!</h2>
        <!-- Score is now inside the report container -->
        <div id="levelReportComplete" class="report-container">
            <h3>Level Performance</h3>
            <div class="report-content-scrollable">
                <p id="finalScoreComplete" class="final-score-report">Your Score: 0</p>
                <p>Detailed report coming soon!</p>
            </div>
        </div>
        <button id="nextLevelBtn">Next Level</button>
        <button id="mainMenuFromCompleteBtn">Main Menu</button>
    </div>

    <div id="gameOverScreen" class="screen">
        <h2>Game Over!</h2>
        <!-- Score is now inside the report container -->
        <div id="gameOverReport" class="report-container">
            <h3>Game Analysis</h3>
            <div class="report-content-scrollable">
                <p id="finalScoreGameOver" class="final-score-report">Your Score: 0</p>
                <p>Performance summary coming soon!</p>
            </div>
        </div>
        <button id="tryAgainBtn">Try Again</button>
        <button id="mainMenuFromGameOverBtn">Main Menu</button>
    </div>

    <script>
        // DOM Elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameUiContainer = document.getElementById('gameUiContainer');
        const problemEl = document.getElementById('problem');
        const scoreEl = document.getElementById('score'); // In-game score
        const shieldsDisplayEl = document.getElementById('shieldsDisplay');

        // Screens & Containers
        const mainMenuScreen = document.getElementById('mainMenu');
        const levelSelectScreen = document.getElementById('levelSelectMenu');
        const practiceLevelsContainer = document.getElementById('practiceLevelsContainer');
        const coreLevelsContainer = document.getElementById('coreLevelsContainer');
        const levelCompleteScreen = document.getElementById('levelCompleteScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const pauseMenuScreen = document.getElementById('pauseMenuScreen'); 

        // Screen Buttons
        const selectLevelBtn = document.getElementById('selectLevelBtn');
        const settingsBtn = document.getElementById('settingsBtn'); 
        const backToMainMenuBtnLvl = document.getElementById('backToMainMenuBtnLvl');
        const nextLevelBtn = document.getElementById('nextLevelBtn');
        const mainMenuFromCompleteBtn = document.getElementById('mainMenuFromCompleteBtn');
        const tryAgainBtn = document.getElementById('tryAgainBtn');
        const mainMenuFromGameOverBtn = document.getElementById('mainMenuFromGameOverBtn');
        
        const pauseGameBtn = document.getElementById('pauseGameBtn'); 
        const resumeGameBtn = document.getElementById('resumeGameBtn'); 
        const pauseMenuSettingsBtn = document.getElementById('pauseMenuSettingsBtn'); 
        const exitToMainMenuBtn = document.getElementById('exitToMainMenuBtn'); 
        
        // Final score elements (now inside report containers)
        const finalScoreCompleteEl = document.getElementById('finalScoreComplete');
        const finalScoreGameOverEl = document.getElementById('finalScoreGameOver');

        // Game States
        const GAME_STATE = {
            MENU: 'MENU', LEVEL_SELECT: 'LEVEL_SELECT', PLAYING: 'PLAYING',
            LEVEL_COMPLETE: 'LEVEL_COMPLETE', GAME_OVER: 'GAME_OVER', PAUSED: 'PAUSED'
        };
        let currentGameState = GAME_STATE.MENU;
        let selectedLevelType = null; 
        let selectedLevelValue = null; 

        // Game Variables & Constants
        let score = 0; // This is the live game score
        const SCORE_TO_WIN = 200; 
        const SCORE_TO_LOSE = -20; 
        const POINTS_CORRECT_ANSWER = 10;
        const POINTS_ENEMY_DESTROYED = 5;
        const PENALTY_WRONG_ANSWER = -5; 
        const PENALTY_MISSED_CORRECT = -5;
        const PENALTY_PLAYER_HIT = -10;

        let spaceship = {
            x: 0, y: 0, width: 40, height: 30, dx: 0, 
            acceleration: 0.5, maxSpeed: 7, friction: 0.92, 
            color: '#00ffff', engineColor1: '#ff4400', engineColor2: '#ffff00',
            shields: 0, isInvincible: false, invincibilityTimer: 0
        };
        let bullets = [];
        let answers = []; 
        let enemies = [];
        let enemyBullets = [];
        let powerups = [];
        let particles = []; 

        let keys = {};
        let mouseX = 0;
        let mouseActive = false;
        const stars = [];
        const numStars = 150;
        const ANSWER_TRAVEL_TIME_SECONDS = 10; 
        
        let questionsAnsweredCorrectlyInLevel = 0;
        const POWERUP_SPAWN_INTERVAL = 3; 
        const POWERUP_TYPES = {
            ANSWER_BOMB: 'ANSWER_BOMB', SHIELD: 'SHIELD', SPARKLE_BOMB: 'SPARKLE_BOMB'
        };
        // const POWERUP_DURATION_QUESTIONS = 3; // Not currently used, but kept for potential future use
        let currentProblem = {}; 


        function setGameState(newState) {
            currentGameState = newState;
            mainMenuScreen.style.display = 'none';
            levelSelectScreen.style.display = 'none';
            levelCompleteScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            pauseMenuScreen.style.display = 'none'; 
            gameUiContainer.style.display = 'none'; 
            canvas.style.display = 'block'; 

            switch (newState) {
                case GAME_STATE.MENU:
                    mainMenuScreen.style.display = 'flex';
                    break;
                case GAME_STATE.LEVEL_SELECT:
                    levelSelectScreen.style.display = 'flex';
                    break;
                case GAME_STATE.PLAYING:
                    gameUiContainer.style.display = 'flex'; 
                    if (!answers.length && !enemies.length) { 
                        resetGameForNewLevel();
                    }
                    break;
                case GAME_STATE.PAUSED: 
                    pauseMenuScreen.style.display = 'flex'; 
                    gameUiContainer.style.display = 'flex'; 
                    break;
                case GAME_STATE.LEVEL_COMPLETE:
                    finalScoreCompleteEl.textContent = `Your Final Score: ${score}`; // Update text content
                    levelCompleteScreen.style.display = 'flex';
                    break;
                case GAME_STATE.GAME_OVER:
                    finalScoreGameOverEl.textContent = `Your Final Score: ${score}`; // Update text content
                    gameOverScreen.style.display = 'flex';
                    break;
            }
        }
        
        function resetGameForNewLevel() {
            score = 0;
            scoreEl.textContent = `Score: ${score}`; // Update in-game score display
            questionsAnsweredCorrectlyInLevel = 0;
            
            bullets = []; answers = []; enemies = []; enemyBullets = []; powerups = []; particles = [];

            spaceship.x = canvas.width / 2; spaceship.y = canvas.height - 80;
            spaceship.dx = 0; spaceship.shields = 0; 
            spaceship.isInvincible = false; spaceship.invincibilityTimer = 0;
            updateShieldsDisplay();

            mouseX = spaceship.x; keys = {}; 
            generateProblem(); 
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            if (currentGameState === GAME_STATE.PLAYING || 
                (currentGameState !== GAME_STATE.MENU && currentGameState !== GAME_STATE.LEVEL_SELECT && spaceship.y === 0) ) {
                 spaceship.x = canvas.width / 2; spaceship.y = canvas.height - 80; 
                 spaceship.dx = 0; 
                 if (answers.length === 0) { generateProblem(); }
            } else if (currentGameState === GAME_STATE.MENU || currentGameState === GAME_STATE.LEVEL_SELECT) {
                spaceship.y = canvas.height - 80; 
            }

            stars.length = 0;
            for (let i = 0; i < numStars; i++) {
                stars.push({
                    x: Math.random() * canvas.width, y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 0.5, speed: Math.random() * 0.5 + 0.1,
                    opacity: Math.random() * 0.5 + 0.3
                });
            }
        }
        
        function checkOverlap(rect1, rect2) {
            // Check if rect1 and rect2 are defined and have necessary properties
            if (!rect1 || !rect2 || 
                typeof rect1.x === 'undefined' || typeof rect1.y === 'undefined' || 
                typeof rect1.width === 'undefined' || typeof rect1.height === 'undefined' ||
                typeof rect2.x === 'undefined' || typeof rect2.y === 'undefined' || 
                typeof rect2.width === 'undefined' || typeof rect2.height === 'undefined') {
                // console.warn("Undefined or incomplete object in checkOverlap:", rect1, rect2);
                return false; 
            }
            return (
                rect1.x - rect1.width / 2 < rect2.x + rect2.width / 2 &&
                rect1.x + rect1.width / 2 > rect2.x - rect2.width / 2 &&
                rect1.y - rect1.height / 2 < rect2.y + rect2.height / 2 &&
                rect1.y + rect1.height / 2 > rect2.y - rect2.height / 2
            );
        }

        function generateProblem() {
            let a, b;
            if (selectedLevelType === 'PRACTICE') {
                a = selectedLevelValue; b = Math.floor(Math.random() * 12) + 1;
                if (Math.random() < 0.5) [a,b] = [b,a]; 
            } else if (selectedLevelType === 'APPRENTICE') {
                a = Math.floor(Math.random() * 6) + 1; b = Math.floor(Math.random() * 6) + 1;
            } else if (selectedLevelType === 'JOURNEYMAN') {
                a = Math.floor(Math.random() * 9) + 1; b = Math.floor(Math.random() * 9) + 1;
            } else if (selectedLevelType === 'MASTER') { 
                a = Math.floor(Math.random() * 12) + 1; b = Math.floor(Math.random() * 12) + 1;
            } else { // Default or if selectedLevelType is somehow null
                a = Math.floor(Math.random() * 10) + 1; b = Math.floor(Math.random() * 10) + 1;
            }
            
            const correctAnswerValue = a * b;
            currentProblem = { a, b, answer: correctAnswerValue };
            problemEl.textContent = `${a} × ${b} = ?`;
            
            answers = []; const usedAnswersValues = new Set([correctAnswerValue]);
            const answerWidth = 70; const answerHeight = 40;
            const answerVy = (canvas.height + answerHeight) / (ANSWER_TRAVEL_TIME_SECONDS * 60);

            let placedCorrect = false;
            for (let attempts = 0; attempts < 50 && !placedCorrect; attempts++) {
                const newAns = { value: correctAnswerValue, x: Math.random() * (canvas.width - answerWidth - 20) + (answerWidth / 2) + 10, y: 0 - answerHeight / 2 - (Math.random() * 20), vy: answerVy, width: answerWidth, height: answerHeight, correct: true };
                if (!answers.some(existing => checkOverlap(newAns, existing))) { answers.push(newAns); placedCorrect = true; }
            }
            if (!placedCorrect) { answers.push({ value: correctAnswerValue, x: canvas.width / 2, y: 0 - answerHeight / 2, vy: answerVy, width: answerWidth, height: answerHeight, correct: true}); }

            const numDistractors = selectedLevelType === 'APPRENTICE' ? 3 : (selectedLevelType === 'JOURNEYMAN' ? 4 : 5);
            for (let i = 0; i < numDistractors; i++) {
                let wrongAnswerValue;
                for (let valAttempts = 0; valAttempts < 20; valAttempts++) {
                    const offset = (Math.random() < 0.5 ? -1 : 1) * (Math.floor(Math.random() * 5) + 1);
                    wrongAnswerValue = correctAnswerValue + offset * (Math.random() < 0.3 ? b : (Math.random() < 0.6 ? a : (Math.floor(Math.random()*5)+1) ));
                    if (wrongAnswerValue <= 0 || wrongAnswerValue > 144) wrongAnswerValue = Math.floor(Math.random() * ( (selectedLevelType === 'MASTER' || selectedLevelType === 'JOURNEYMAN') ? 144: (selectedLevelType === 'APPRENTICE' ? 36 : 100))) + 1;
                    if (!usedAnswersValues.has(wrongAnswerValue)) break;
                }
                if (usedAnswersValues.has(wrongAnswerValue)) continue; usedAnswersValues.add(wrongAnswerValue);

                for (let posAttempts = 0; posAttempts < 30; posAttempts++) {
                    const newDist = { value: wrongAnswerValue, x: Math.random() * (canvas.width - answerWidth - 20) + (answerWidth / 2) + 10, y: 0 - answerHeight / 2 - (Math.random() * 70), vy: answerVy, width: answerWidth, height: answerHeight, correct: false };
                    if (!answers.some(existing => checkOverlap(newDist, existing))) { answers.push(newDist); break; }
                }
            }
            spawnEnemies();
            if ( (selectedLevelType === 'JOURNEYMAN' || selectedLevelType === 'MASTER') && (questionsAnsweredCorrectlyInLevel > 0 && questionsAnsweredCorrectlyInLevel % POWERUP_SPAWN_INTERVAL === 0) ) {
                spawnPowerup();
            }
        }

        function spawnEnemies() {
            enemies = []; const enemyWidth = spaceship.width; const enemyHeight = spaceship.height;
            const enemyVy = (canvas.height + enemyHeight) / ((ANSWER_TRAVEL_TIME_SECONDS + 2) * 60); 
            let numEnemiesToSpawn = 0; let fireRate = 3000; let canTarget = false;

            if (selectedLevelType === 'APPRENTICE') { numEnemiesToSpawn = 1; fireRate = 3000; } 
            else if (selectedLevelType === 'JOURNEYMAN') { numEnemiesToSpawn = 2; fireRate = 2000; } 
            else if (selectedLevelType === 'MASTER') { numEnemiesToSpawn = 2; fireRate = 2000; canTarget = true; }

            for (let i = 0; i < numEnemiesToSpawn; i++) {
                let placed = false;
                for(let attempt = 0; attempt < 20 && !placed; attempt++) {
                    const newEnemy = { x: Math.random() * (canvas.width - enemyWidth - 20) + (enemyWidth / 2) + 10, y: 0 - enemyHeight - (Math.random() * 100), width: enemyWidth, height: enemyHeight, vy: enemyVy, color: '#FF6347', fireRate: fireRate, lastFiredTime: Date.now() + Math.random() * fireRate, canTarget: canTarget, health: 1 };
                    let overlaps = answers.some(ans => checkOverlap(newEnemy, ans)) || enemies.some(en => checkOverlap(newEnemy, en));
                    if (!overlaps) { enemies.push(newEnemy); placed = true; }
                }
            }
        }
        
        function spawnPowerup() {
            if (powerups.length > 0) return; 
            const powerupTypesArray = Object.values(POWERUP_TYPES);
            const type = powerupTypesArray[Math.floor(Math.random() * powerupTypesArray.length)];
            const powerupSize = 30; const powerupVy = (canvas.height + powerupSize) / ((ANSWER_TRAVEL_TIME_SECONDS - 2) * 60); 
            powerups.push({ x: Math.random() * (canvas.width - powerupSize - 20) + (powerupSize / 2) + 10, y: 0 - powerupSize / 2, width: powerupSize, height: powerupSize, vy: powerupVy, type: type, acquired: false, activeDuration: 0, iconText: type === POWERUP_TYPES.ANSWER_BOMB ? 'B💣' : (type === POWERUP_TYPES.SHIELD ? 'S🛡️' : '✨') });
        }

        function drawSpaceship() { 
            if (spaceship.isInvincible && Math.floor(Date.now() / 100) % 2 === 0) { /* Don't draw if invincible and flashing */ } 
            else {
                ctx.fillStyle = spaceship.color; ctx.beginPath();
                ctx.moveTo(spaceship.x, spaceship.y); ctx.lineTo(spaceship.x - spaceship.width / 2, spaceship.y + spaceship.height); 
                ctx.lineTo(spaceship.x + spaceship.width / 2, spaceship.y + spaceship.height); ctx.closePath(); ctx.fill();
                const engineGlowHeight = 10 + Math.random() * 5; 
                ctx.fillStyle = spaceship.engineColor1; ctx.fillRect(spaceship.x - 4, spaceship.y + spaceship.height, 8, engineGlowHeight);
                ctx.fillStyle = spaceship.engineColor2; ctx.fillRect(spaceship.x - 2, spaceship.y + spaceship.height, 4, engineGlowHeight - 2);
            }
        }

        function drawBullets(bulletArray, color = '#ffff00', radius = 4) { 
            bulletArray.forEach(bullet => {
                ctx.fillStyle = bullet.color || color; ctx.beginPath(); ctx.arc(bullet.x, bullet.y, bullet.radius || radius, 0, Math.PI * 2);
                ctx.fill(); ctx.shadowColor = bullet.color || color; ctx.shadowBlur = 8; ctx.fill(); ctx.shadowBlur = 0; 
            });
        }

        function drawRoundedRect(ctx, x, y, width, height, radius) { 
            ctx.beginPath(); ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y); ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius); ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height); ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius); ctx.quadraticCurveTo(x, y, x + radius, y); ctx.closePath();
        }

        function drawAnswers() { 
            answers.forEach(answer => {
                ctx.fillStyle = 'rgba(0, 100, 255, 0.7)'; ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 2;
                drawRoundedRect(ctx, answer.x - answer.width / 2, answer.y - answer.height / 2, answer.width, answer.height, 8);
                ctx.fill(); ctx.stroke();
                ctx.fillStyle = 'white'; ctx.font = 'bold 18px Inter, Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; 
                ctx.fillText(answer.value, answer.x, answer.y);
            });
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                ctx.fillStyle = enemy.color; ctx.beginPath(); ctx.moveTo(enemy.x, enemy.y + enemy.height); 
                ctx.lineTo(enemy.x - enemy.width / 2, enemy.y); ctx.lineTo(enemy.x + enemy.width / 2, enemy.y); 
                ctx.closePath(); ctx.fill();
            });
        }

        function drawPowerups() {
            powerups.forEach(p => {
                if (!p.acquired) {
                    ctx.fillStyle = p.type === POWERUP_TYPES.SHIELD ? 'rgba(0, 255, 0, 0.7)' : p.type === POWERUP_TYPES.ANSWER_BOMB ? 'rgba(255, 165, 0, 0.7)' : 'rgba(255, 255, 0, 0.7)'; 
                    ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 2;
                    drawRoundedRect(ctx, p.x - p.width/2, p.y - p.height/2, p.width, p.height, 5);
                    ctx.fill(); ctx.stroke();
                    ctx.fillStyle = 'black'; ctx.font = 'bold 16px Inter, Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(p.iconText, p.x, p.y);
                }
            });
        }

        function drawParticles() {
            particles.forEach(p => { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); });
        }

        function drawStars() { 
            stars.forEach(star => {
                ctx.fillStyle = 'white'; star.opacity += (Math.random() - 0.5) * 0.1;
                star.opacity = Math.max(0.2, Math.min(1, star.opacity)); 
                ctx.globalAlpha = star.opacity; ctx.beginPath(); ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2); ctx.fill();
            });
            ctx.globalAlpha = 1; 
        }

        function updateShieldsDisplay() { shieldsDisplayEl.textContent = spaceship.shields > 0 ? `Shields: ${'🛡️'.repeat(spaceship.shields)}` : ""; }

        function activatePowerup(powerup) {
            powerup.acquired = true; powerups = powerups.filter(p => p !== powerup); 
            if (powerup.type === POWERUP_TYPES.ANSWER_BOMB) { answers = answers.filter(ans => ans.correct); } 
            else if (powerup.type === POWERUP_TYPES.SHIELD) { spaceship.shields = 2; updateShieldsDisplay(); } 
            else if (powerup.type === POWERUP_TYPES.SPARKLE_BOMB) {
                for (let i = 0; i < 100; i++) { particles.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: Math.random() * 3 + 1, color: `rgba(255, 255, ${Math.floor(Math.random() * 155) + 100}, ${Math.random() * 0.5 + 0.5})`, life: 60 + Math.random() * 60, vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4 }); }
            }
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i]; p.x += p.vx; p.y += p.vy; p.life--;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function update() {
            if (currentGameState === GAME_STATE.PAUSED) {
                 stars.forEach(star => { 
                    star.y += star.speed * 0.5; 
                    if (star.y > canvas.height + star.size) { star.y = -star.size; star.x = Math.random() * canvas.width; }
                });
                updateParticles(); return; 
            }

            stars.forEach(star => { 
                star.y += star.speed;
                if (star.y > canvas.height + star.size) { star.y = -star.size; star.x = Math.random() * canvas.width; }
            });
            updateParticles();

            if (spaceship.isInvincible) { spaceship.invincibilityTimer -= 1000/60; if (spaceship.invincibilityTimer <= 0) spaceship.isInvincible = false; }

            let moveLeft = keys['ArrowLeft']; let moveRight = keys['ArrowRight'];
            if (moveLeft) spaceship.dx -= spaceship.acceleration; if (moveRight) spaceship.dx += spaceship.acceleration;
            if (!moveLeft && !moveRight) spaceship.dx *= spaceship.friction;
            if (Math.abs(spaceship.dx) < 0.1 && !moveLeft && !moveRight) spaceship.dx = 0;
            if (spaceship.dx > spaceship.maxSpeed) spaceship.dx = spaceship.maxSpeed; if (spaceship.dx < -spaceship.maxSpeed) spaceship.dx = -spaceship.maxSpeed;
            spaceship.x += spaceship.dx;
            if (spaceship.x - spaceship.width / 2 < 0) { spaceship.x = spaceship.width / 2; spaceship.dx = 0; }
            if (spaceship.x + spaceship.width / 2 > canvas.width) { spaceship.x = canvas.width - spaceship.width / 2; spaceship.dx = 0; }
            if (mouseActive) { 
                spaceship.x = mouseX; spaceship.dx = 0; 
                if (spaceship.x < spaceship.width / 2) spaceship.x = spaceship.width / 2;
                if (spaceship.x > canvas.width - spaceship.width / 2) spaceship.x = canvas.width - spaceship.width / 2;
                mouseActive = false; 
            }

            bullets = bullets.filter(b => { b.y -= b.speed; return b.y > -b.radius; });
            enemyBullets = enemyBullets.filter(eb => { eb.y += eb.vy; eb.x += eb.vx; return eb.y < canvas.height + eb.radius && eb.y > -eb.radius && eb.x > -eb.radius && eb.x < canvas.width + eb.radius; });

            let correctAnsMissed = false;
            for (let i = answers.length - 1; i >= 0; i--) {
                const answer = answers[i]; answer.y += answer.vy;
                if (answer.y - answer.height / 2 > canvas.height) { if (answer.correct) correctAnsMissed = true; answers.splice(i, 1); }
            }
            if (correctAnsMissed) {
                score += PENALTY_MISSED_CORRECT; scoreEl.textContent = `Score: ${score}`;
                if (score <= SCORE_TO_LOSE) setGameState(GAME_STATE.GAME_OVER); else generateProblem();
            }

            const currentTime = Date.now();
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i]; enemy.y += enemy.vy;
                if (enemy.y - enemy.height / 2 > canvas.height) { enemies.splice(i, 1); continue; }
                if (currentTime > enemy.lastFiredTime + enemy.fireRate) {
                    enemy.lastFiredTime = currentTime; let bulletVx = 0; let bulletVy = 5; 
                    if (enemy.canTarget) {
                        const angleToPlayer = Math.atan2(spaceship.y - enemy.y, spaceship.x - enemy.x);
                        bulletVx = Math.cos(angleToPlayer) * bulletVy; bulletVy = Math.sin(angleToPlayer) * bulletVy;
                        if (bulletVy < 2) bulletVy = 2; 
                    }
                    enemyBullets.push({ x: enemy.x, y: enemy.y + enemy.height / 2, vx: bulletVx, vy: bulletVy, radius: 3, color: '#FF6347' });
                }
            }
            
            for (let i = powerups.length - 1; i >= 0; i--) { const p = powerups[i]; if (!p.acquired) { p.y += p.vy; if (p.y - p.height / 2 > canvas.height) powerups.splice(i, 1); } }

            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i]; let bulletHitSomething = false;
                for (let j = answers.length - 1; j >= 0; j--) {
                    const answer = answers[j];
                    if (checkOverlap({x:bullet.x, y:bullet.y, width:bullet.radius*2, height:bullet.radius*2}, answer)) {
                        bullets.splice(i, 1); bulletHitSomething = true;
                        if (answer.correct) {
                            score += POINTS_CORRECT_ANSWER; questionsAnsweredCorrectlyInLevel++;
                            if (score >= SCORE_TO_WIN) setGameState(GAME_STATE.LEVEL_COMPLETE); else generateProblem();
                        } else {
                            score += PENALTY_WRONG_ANSWER; answers.splice(j, 1);
                            if (answers.length === 0 || !answers.some(ans => ans.correct)) { if (score > SCORE_TO_LOSE) generateProblem(); }
                        }
                        scoreEl.textContent = `Score: ${score}`;
                        if (score <= SCORE_TO_LOSE && currentGameState === GAME_STATE.PLAYING) setGameState(GAME_STATE.GAME_OVER);
                        break; 
                    }
                }
                if (bulletHitSomething) continue;
                for (let k = enemies.length - 1; k >= 0; k--) {
                    const enemy = enemies[k];
                     if (checkOverlap({x:bullet.x, y:bullet.y, width:bullet.radius*2, height:bullet.radius*2}, enemy)) {
                        bullets.splice(i, 1); bulletHitSomething = true; enemy.health--; 
                        if (enemy.health <= 0) { enemies.splice(k, 1); score += POINTS_ENEMY_DESTROYED; scoreEl.textContent = `Score: ${score}`; }
                        break;
                    }
                }
                if (bulletHitSomething) continue;
                for (let l = powerups.length - 1; l >= 0; l--) { const p = powerups[l]; if (!p.acquired && checkOverlap({x:bullet.x, y:bullet.y, width:bullet.radius*2, height:bullet.radius*2}, p)) { bullets.splice(i, 1); bulletHitSomething = true; activatePowerup(p); break; } }
            }

            if (!spaceship.isInvincible) {
                for (let i = enemyBullets.length - 1; i >= 0; i--) {
                    const eb = enemyBullets[i];
                    if (checkOverlap({x:eb.x, y:eb.y, width:eb.radius*2, height:eb.radius*2}, spaceship)) {
                        enemyBullets.splice(i, 1);
                        if (spaceship.shields > 0) { spaceship.shields--; updateShieldsDisplay(); spaceship.isInvincible = true; spaceship.invincibilityTimer = 1000; } 
                        else { setGameState(GAME_STATE.GAME_OVER); }
                        break; 
                    }
                }
            }
            if (!spaceship.isInvincible) {
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (checkOverlap(enemy, spaceship)) {
                         if (spaceship.shields > 0) { spaceship.shields--; updateShieldsDisplay(); spaceship.isInvincible = true; spaceship.invincibilityTimer = 1500; enemies.splice(i,1); } 
                         else { setGameState(GAME_STATE.GAME_OVER); }
                        break;
                    }
                }
            }
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawStars(); drawParticles();
            if (currentGameState === GAME_STATE.PLAYING || currentGameState === GAME_STATE.PAUSED) {
                drawAnswers(); drawEnemies(); drawPowerups(); drawSpaceship();
                drawBullets(bullets, '#ffff00', 4); drawBullets(enemyBullets, '#FF6347', 3); 
            }
        }

        function gameLoop() { update(); render(); requestAnimationFrame(gameLoop); }
        function shoot() { if (currentGameState !== GAME_STATE.PLAYING) return; bullets.push({ x: spaceship.x, y: spaceship.y, radius: 4, speed: 10, color: '#ffff00' }); }

        function nextLevelSelection() {
            if (selectedLevelType == "PRACTICE" && selectedLevelValue <= 11) { selectedLevelValue = selectedLevelValue + 1; }
            else if (selectedLevelType == "PRACTICE" && selectedLevelValue == 12) { selectedLevelType="APPRENTICE"; selectedLevelValue = null; }
            else if (selectedLevelType=="APPRENTICE") { selectedLevelType="JOURNEYMAN"; }
            else if (selectedLevelType=="JOURNEYMAN") { selectedLevelType="MASTER"; }
            setGameState(GAME_STATE.PLAYING); 
        }

        function setupEventListeners() {
            selectLevelBtn.addEventListener('click', () => setGameState(GAME_STATE.LEVEL_SELECT));
            settingsBtn.addEventListener('click', () => alert('Settings: Coming Soon!')); 
            backToMainMenuBtnLvl.addEventListener('click', () => setGameState(GAME_STATE.MENU));
            mainMenuFromCompleteBtn.addEventListener('click', () => setGameState(GAME_STATE.MENU));
            mainMenuFromGameOverBtn.addEventListener('click', () => setGameState(GAME_STATE.MENU));
            tryAgainBtn.addEventListener('click', () => { setGameState(GAME_STATE.PLAYING); });
            nextLevelBtn.addEventListener('click', () => {nextLevelSelection();});

            pauseGameBtn.addEventListener('click', () => { if (currentGameState === GAME_STATE.PLAYING) { setGameState(GAME_STATE.PAUSED); } });
            resumeGameBtn.addEventListener('click', () => { if (currentGameState === GAME_STATE.PAUSED) { setGameState(GAME_STATE.PLAYING); } });
            // Ensuring the pause menu settings button has the correct alert
            pauseMenuSettingsBtn.addEventListener('click', () => alert('Settings: Coming Soon!'));
            exitToMainMenuBtn.addEventListener('click', () => { setGameState(GAME_STATE.MENU); });

            document.addEventListener('keydown', (e) => {
                if (currentGameState === GAME_STATE.PLAYING) { 
                    keys[e.code] = true; if (e.code === 'Space') { e.preventDefault(); shoot(); }
                }
                if (e.code === 'Escape') {
                    e.preventDefault();
                    if (currentGameState === GAME_STATE.PLAYING) { setGameState(GAME_STATE.PAUSED); } 
                    else if (currentGameState === GAME_STATE.PAUSED) { setGameState(GAME_STATE.PLAYING); }
                }
            });
            document.addEventListener('keyup', (e) => { if (currentGameState === GAME_STATE.PLAYING) keys[e.code] = false; });
            canvas.addEventListener('mousemove', (e) => { if (currentGameState === GAME_STATE.PLAYING) { const rect = canvas.getBoundingClientRect(); mouseX = e.clientX - rect.left; mouseActive = true; } });
            canvas.addEventListener('click', (e) => { if (currentGameState === GAME_STATE.PLAYING) shoot(); });
            window.addEventListener('resize', resizeCanvas);
        }

        function populateLevelSelectMenu() {
            practiceLevelsContainer.innerHTML = ''; coreLevelsContainer.innerHTML = '';
            for (let i = 1; i <= 12; i++) {
                const btn = document.createElement('button'); btn.textContent = i;
                btn.addEventListener('click', () => { selectedLevelType = 'PRACTICE'; selectedLevelValue = i; setGameState(GAME_STATE.PLAYING); });
                practiceLevelsContainer.appendChild(btn);
            }
            const coreLevels = [ { name: "Apprentice Blaster", type: 'APPRENTICE' }, { name: "Journeyman Blaster", type: 'JOURNEYMAN' }, { name: "Master Blaster", type: 'MASTER' } ];
            coreLevels.forEach(level => {
                const btn = document.createElement('button'); btn.textContent = level.name; btn.classList.add('core-level-button');
                btn.addEventListener('click', () => { selectedLevelType = level.type; selectedLevelValue = null; setGameState(GAME_STATE.PLAYING); });
                coreLevelsContainer.appendChild(btn);
            });
        }

        window.onload = () => { resizeCanvas(); populateLevelSelectMenu(); setupEventListeners(); setGameState(GAME_STATE.MENU); gameLoop(); };
    </script>
</body>
</html>